/**
 * Character Thoughts Rendering Module
 * Handles rendering of character thoughts panel and floating thought bubbles in chat
 */

import { getContext } from '../../../../../../extensions.js';
import { this_chid, characters } from '../../../../../../../script.js';
import { selected_group, getGroupMembers } from '../../../../../../group-chats.js';
import {
    extensionSettings,
    lastGeneratedData,
    committedTrackerData,
    $thoughtsContainer,
    FALLBACK_AVATAR_DATA_URI,
    addDebugLog
} from '../../core/state.js';
import { saveChatData } from '../../core/persistence.js';
import { getSafeThumbnailUrl } from '../../utils/avatars.js';
import { saveSettings } from '../../core/persistence.js';
import { isGenerating, regenerateAvatar } from '../features/avatarGenerator.js';
import { regenerateCharacterFromCard } from '../ui/characterEditor.js';

/**
 * Helper to log to both console and debug logs array
 */
function debugLog(message, data = null) {
    console.log(message, data || '');
    if (extensionSettings.debugMode) {
        addDebugLog(message, data);
    }
}

/**
 * Escapes HTML attribute values to prevent quotes from breaking HTML
 */
function escapeHtmlAttr(str) {
    if (!str) return '';
    return String(str).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

/**
 * Renders a relationship badge, supporting both emoji and custom images
 * @param {string} value - Either an emoji or a custom image path in format [IMG:path]
 * @returns {string} HTML string for the badge content
 */
function renderRelationshipBadge(value) {
    if (!value) return '‚öñÔ∏è';

    // Check if it's a custom image path
    if (value.startsWith('[IMG:') && value.endsWith(']')) {
        const imagePath = value.slice(5, -1); // Extract path from [IMG:path]
        return `<img src="${imagePath}" class="rpg-relationship-badge-img" alt="Relationship" />`;
    }

    // Otherwise it's a standard emoji
    return value;
}

/**
 * Interpolates color based on percentage value between low and high colors
 * @param {number} percentage - Value from 0-100
 * @param {string} lowColor - Hex color for low values (e.g., '#ff0000')
 * @param {string} highColor - Hex color for high values (e.g., '#00ff00')
 * @returns {string} Interpolated hex color
 */
function getStatColor(percentage, lowColor, highColor) {
    // Clamp percentage to 0-100
    const percent = Math.max(0, Math.min(100, percentage)) / 100;

    // Parse hex colors
    const parsehex = (hex) => {
        const clean = hex.replace('#', '');
        return {
            r: parseInt(clean.substring(0, 2), 16),
            g: parseInt(clean.substring(2, 4), 16),
            b: parseInt(clean.substring(4, 6), 16)
        };
    };

    const low = parsehex(lowColor);
    const high = parsehex(highColor);

    // Interpolate each channel
    const r = Math.round(low.r + (high.r - low.r) * percent);
    const g = Math.round(low.g + (high.g - low.g) * percent);
    const b = Math.round(low.b + (high.b - low.b) * percent);

    // Convert back to hex
    const toHex = (n) => n.toString(16).padStart(2, '0');
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

/**
 * Fuzzy name matching that handles:
 * - Exact matches: "Sabrina" === "Sabrina"
 * - Parenthetical additions: "Sabrina" matches "Sabrina (Margrokha's Avatar)"
 * - Title additions: "Sabrina" matches "Princess Sabrina"
 * - Word boundaries: "Sabrina" won't match "Sabrina's Mother"
 *
 * @param {string} cardName - Name from the character card
 * @param {string} aiName - Name generated by the AI
 * @returns {boolean} True if names match
 */
function namesMatch(cardName, aiName) {
    if (!cardName || !aiName) return false;

    // 1. Exact match (fast path)
    if (cardName.toLowerCase() === aiName.toLowerCase()) return true;

    // 2. Strip parentheses and quotes from both names and match
    // This allows "Dottore (Prime)" to match "Dottore" card for avatar lookup
    // and "Marianna "Mari"" to match "Marianna" or "Mari" cards
    const stripParensAndQuotes = (s) => s.replace(/\s*\([^)]*\)/g, '').replace(/["']/g, '').trim();
    const cardCore = stripParensAndQuotes(cardName).toLowerCase();
    const aiCore = stripParensAndQuotes(aiName).toLowerCase();
    if (cardCore === aiCore) return true;

    // 3. Check if card name appears as complete word in AI name
    // Escape special regex characters to prevent "Invalid regular expression" errors
    const escapedCardCore = cardCore.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const wordBoundary = new RegExp(`\\b${escapedCardCore}\\b`);
    return wordBoundary.test(aiCore);
}

/**
 * Gets the avatar URL for a character, checking custom NPC avatars first
 * @param {string} characterName - Name of the character
 * @returns {string} Avatar URL or fallback
 *
 * TODO: This function may be involved in the character card stacking bug
 * When avatars are loaded from the character library (via getSafeThumbnailUrl),
 * the image loading timing can cause a race condition with flex layout calculation.
 * See detailed notes in src/systems/ui/characterEditor.js forceLayoutRefresh()
 * Potential fix: Add image preloading or onload callbacks to ensure layout stability
 */
function getCharacterAvatar(characterName) {
    // First, check if there's a custom NPC avatar
    if (extensionSettings.npcAvatars && extensionSettings.npcAvatars[characterName]) {
        const avatar = extensionSettings.npcAvatars[characterName];
        // Skip if not a valid string (e.g., if it's an object from a previous bug)
        if (typeof avatar === 'string' && avatar) {
            debugLog(`[RPG Thoughts] Found custom NPC avatar for: ${characterName}`);
            return avatar;
        } else {
            // Clear invalid avatar data
            console.warn(`[RPG Thoughts] Invalid avatar data for ${characterName}, clearing...`);
            delete extensionSettings.npcAvatars[characterName];
        }
    }

    // Use the existing avatar lookup logic
    let characterPortrait = FALLBACK_AVATAR_DATA_URI;
    let hasAvatar = false;

    // For group chats, search through group members first
    if (selected_group) {
        try {
            const groupMembers = getGroupMembers(selected_group);
            if (groupMembers && groupMembers.length > 0) {
                const matchingMember = groupMembers.find(member =>
                    member && member.name && namesMatch(member.name, characterName)
                );

                if (matchingMember && matchingMember.avatar && matchingMember.avatar !== 'none') {
                    const thumbnailUrl = getSafeThumbnailUrl('avatar', matchingMember.avatar);
                    if (thumbnailUrl) {
                        hasAvatar = true;
                        return thumbnailUrl;
                    }
                }
            }
        } catch (groupError) {
            debugLog('[RPG Thoughts] Error checking group members:', groupError.message);
        }
    }

    // For regular chats or if not found in group, search all characters
    if (characters && characters.length > 0) {
        const matchingCharacter = characters.find(c =>
            c && c.name && namesMatch(c.name, characterName)
        );

        if (matchingCharacter && matchingCharacter.avatar && matchingCharacter.avatar !== 'none') {
            const thumbnailUrl = getSafeThumbnailUrl('avatar', matchingCharacter.avatar);
            if (thumbnailUrl) {
                hasAvatar = true;
                return thumbnailUrl;
            }
        }
    }

    // If this is the current character in a 1-on-1 chat, use their portrait
    if (this_chid !== undefined && characters[this_chid] &&
        characters[this_chid].name && namesMatch(characters[this_chid].name, characterName)) {
        const thumbnailUrl = getSafeThumbnailUrl('avatar', characters[this_chid].avatar);
        if (thumbnailUrl) {
            hasAvatar = true;
            return thumbnailUrl;
        }
    }

    return characterPortrait;
}

/**
 * Handles uploading a custom avatar for an NPC character
 * @param {string} characterName - Name of the character to set avatar for
 */
function uploadNpcAvatar(characterName) {
    // Create a file input element
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';

    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        // Validate file size (max 2MB to keep settings file reasonable)
        if (file.size > 2 * 1024 * 1024) {
            console.error('[RPG Companion] Image file too large. Maximum size is 2MB.');
            // You could add a toast notification here if available
            return;
        }

        // Validate file type
        if (!file.type.startsWith('image/')) {
            console.error('[RPG Companion] Invalid file type. Please select an image.');
            return;
        }

        try {
            // Read the file and convert to base64 data URI
            const reader = new FileReader();
            reader.onload = (event) => {
                const dataUri = event.target.result;

                // Initialize npcAvatars if it doesn't exist
                if (!extensionSettings.npcAvatars) {
                    extensionSettings.npcAvatars = {};
                }

                // Store the avatar
                extensionSettings.npcAvatars[characterName] = dataUri;

                // Save settings
                saveSettings();

                console.log(`[RPG Companion] Avatar uploaded for NPC: ${characterName}`);

                // Re-render to show the new avatar
                renderThoughts();
            };

            reader.onerror = (error) => {
                console.error('[RPG Companion] Error reading image file:', error);
            };

            reader.readAsDataURL(file);
        } catch (error) {
            console.error('[RPG Companion] Error uploading avatar:', error);
        }
    };

    // Trigger the file input
    input.click();
}

/**
 * Removes a character from the Present Characters panel and saved data
 * @param {string} characterName - Name of the character to remove
 */
function removeCharacter(characterName) {
    console.log(`[RPG Companion] Removing character: ${characterName}`);

    // Initialize if it doesn't exist
    if (!lastGeneratedData.characterThoughts) {
        return;
    }

    const lines = lastGeneratedData.characterThoughts.split('\n');
    const newLines = [];
    let skipUntilNextCharacter = false;
    let foundCharacter = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // Check if this is the start of the character we want to remove
        if (line.startsWith('- ')) {
            const name = line.substring(2).trim();
            if (name.toLowerCase() === characterName.toLowerCase()) {
                foundCharacter = true;
                skipUntilNextCharacter = true;
                continue; // Skip this line
            } else {
                // This is a different character, stop skipping
                skipUntilNextCharacter = false;
            }
        }

        // If we're not skipping, add the line
        if (!skipUntilNextCharacter) {
            newLines.push(lines[i]);
        }
    }

    if (foundCharacter) {
        // Update both lastGeneratedData and committedTrackerData
        lastGeneratedData.characterThoughts = newLines.join('\n');
        committedTrackerData.characterThoughts = newLines.join('\n');

        // Save to chat metadata
        saveChatData();

        console.log(`[RPG Companion] Character removed: ${characterName}`);

        // Preserve scroll position before re-rendering
        const scrollTop = $thoughtsContainer ? $thoughtsContainer.scrollTop() : 0;

        // Re-render the panel
        renderThoughts();

        // Restore scroll position after re-rendering (use setTimeout to ensure DOM is updated)
        if ($thoughtsContainer && scrollTop > 0) {
            setTimeout(() => {
                $thoughtsContainer.scrollTop(scrollTop);
            }, 0);
        }
    } else {
        console.warn(`[RPG Companion] Character not found: ${characterName}`);
    }
}

/**
 * Toggles the pin status of a character
 * Pinned characters persist through regeneration even if LLM doesn't mention them
 * @param {string} characterName - Name of the character to pin/unpin
 */
function togglePinCharacter(characterName) {
    console.log(`[RPG Companion] Toggling pin for character: ${characterName}`);

    // Initialize pinnedCharacters array if it doesn't exist
    if (!extensionSettings.pinnedCharacters) {
        extensionSettings.pinnedCharacters = [];
    }

    const index = extensionSettings.pinnedCharacters.findIndex(
        name => name.toLowerCase() === characterName.toLowerCase()
    );

    if (index >= 0) {
        // Character is pinned, unpin it
        extensionSettings.pinnedCharacters.splice(index, 1);
        console.log(`[RPG Companion] Unpinned character: ${characterName}`);
        toastr.info(`${characterName} unpinned`, 'RPG Companion');
    } else {
        // Character is not pinned, pin it
        extensionSettings.pinnedCharacters.push(characterName);
        console.log(`[RPG Companion] Pinned character: ${characterName}`);
        toastr.success(`${characterName} pinned - will persist through regeneration`, 'RPG Companion');
    }

    // Save settings
    saveSettings();

    // Re-render to update pin button appearance
    const scrollTop = $thoughtsContainer ? $thoughtsContainer.scrollTop() : 0;
    renderThoughts();
    if ($thoughtsContainer && scrollTop > 0) {
        setTimeout(() => {
            $thoughtsContainer.scrollTop(scrollTop);
        }, 0);
    }
}

/**
 * Toggles the freeze status of a character
 * Frozen characters have their state locked and won't be updated during regeneration
 * @param {string} characterName - Name of the character to freeze/unfreeze
 */
function toggleFreezeCharacter(characterName) {
    console.log(`[RPG Companion] Toggling freeze for character: ${characterName}`);

    // Initialize frozenCharacters object if it doesn't exist
    if (!extensionSettings.frozenCharacters) {
        extensionSettings.frozenCharacters = {};
    }

    const lowerName = characterName.toLowerCase();

    if (extensionSettings.frozenCharacters[lowerName]) {
        // Character is frozen, unfreeze it
        delete extensionSettings.frozenCharacters[lowerName];
        console.log(`[RPG Companion] Unfroze character: ${characterName}`);
        toastr.info(`${characterName} unfrozen - will update during regeneration`, 'RPG Companion');
    } else {
        // Character is not frozen, freeze it
        // Store the current character data
        const characterData = getCurrentCharacterData(characterName);
        if (characterData) {
            extensionSettings.frozenCharacters[lowerName] = characterData;
            console.log(`[RPG Companion] Froze character: ${characterName}`);
            toastr.success(`${characterName} frozen - state locked and protected from updates`, 'RPG Companion');
        } else {
            console.warn(`[RPG Companion] Could not find character data for: ${characterName}`);
            toastr.error(`Could not freeze ${characterName} - character data not found`, 'RPG Companion');
            return;
        }
    }

    // Save settings
    saveSettings();

    // Re-render to update freeze button appearance
    const scrollTop = $thoughtsContainer ? $thoughtsContainer.scrollTop() : 0;
    renderThoughts();
    if ($thoughtsContainer && scrollTop > 0) {
        setTimeout(() => {
            $thoughtsContainer.scrollTop(scrollTop);
        }, 0);
    }
}

/**
 * Gets the current data for a specific character from lastGeneratedData
 * @param {string} characterName - Name of the character
 * @returns {string|null} The character's data block or null if not found
 */
function getCurrentCharacterData(characterName) {
    if (!lastGeneratedData.characterThoughts) {
        return null;
    }

    const lines = lastGeneratedData.characterThoughts.split('\n');
    let currentCharName = null;
    let currentCharBlock = [];
    let foundCharacter = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line.startsWith('- ')) {
            // If we were building a character block and it matches, save it
            if (currentCharName && currentCharName.toLowerCase() === characterName.toLowerCase()) {
                foundCharacter = true;
                break;
            }

            // Start new character
            currentCharName = line.substring(2).trim();
            currentCharBlock = [lines[i]];
        } else if (currentCharName) {
            currentCharBlock.push(lines[i]);
        }
    }

    // Check if the last character matches
    if (!foundCharacter && currentCharName && currentCharName.toLowerCase() === characterName.toLowerCase()) {
        foundCharacter = true;
    }

    return foundCharacter ? currentCharBlock.join('\n') : null;
}

/**
 * Renders character thoughts (Present Characters) panel.
 * Displays character cards with avatars, relationship badges, and traits.
 * Includes event listeners for editable character fields.
 */
export function renderThoughts() {
    if (!extensionSettings.showCharacterThoughts || !$thoughtsContainer) {
        return;
    }

    debugLog('[RPG Thoughts] ==================== RENDERING PRESENT CHARACTERS ====================');
    debugLog('[RPG Thoughts] showCharacterThoughts setting:', extensionSettings.showCharacterThoughts);
    debugLog('[RPG Thoughts] Container exists:', !!$thoughtsContainer);

    // Add updating class for animation
    if (extensionSettings.enableAnimations) {
        $thoughtsContainer.addClass('rpg-content-updating');
    }

    // Get tracker configuration
    const config = extensionSettings.trackerConfig?.presentCharacters;
    const enabledFields = config?.customFields?.filter(f => f && f.enabled && f.name) || [];
    const characterStatsConfig = config?.characterStats;
    const enabledCharStats = characterStatsConfig?.enabled && characterStatsConfig?.customStats?.filter(s => s && s.enabled && s.name) || [];
    const relationshipFields = config?.relationshipFields || [];
    const hasRelationshipEnabled = relationshipFields.length > 0;

    // Use committedTrackerData as fallback if lastGeneratedData is empty (e.g., after page refresh)
    const characterThoughtsData = lastGeneratedData.characterThoughts || committedTrackerData.characterThoughts || '';

    debugLog('[RPG Thoughts] Raw characterThoughts data:', characterThoughtsData);
    debugLog('[RPG Thoughts] Data length:', characterThoughtsData.length + ' chars');
    debugLog('[RPG Thoughts] Enabled custom fields:', enabledFields.map(f => f.name));
    debugLog('[RPG Thoughts] Enabled character stats:', enabledCharStats.map(s => s.name));

    const lines = characterThoughtsData.split('\n');
    const presentCharacters = [];

    debugLog('[RPG Thoughts] Split into lines count:', lines.length);
    debugLog('[RPG Thoughts] Lines:', lines);

    // Parse new multi-line format:
    // - [Name]
    // Details: [Emoji] | [Field1] | [Field2] | ...
    // Relationship: [Relationship]
    // Stats: Stat1: X% | Stat2: X% | ...
    // Thoughts: [Description]
    let lineNumber = 0;
    let currentCharacter = null;

    // Pre-process: normalize the format to handle cases where "- char" appears mid-line
    // This handles: "Thoughts: ... - char 2" by splitting it into separate lines
    const normalizedLines = [];
    for (let line of lines) {
        // Check if line contains "- [name]" pattern after some content (not at start)
        // Match pattern like "some text - CharName" where there's content before the dash
        const midLineCharMatch = line.match(/^(.+?)\s+-\s+([A-Z][a-zA-Z\s]+)$/);
        if (midLineCharMatch && !line.trim().startsWith('- ')) {
            // Split: first part stays as one line, "- Name" becomes new line
            normalizedLines.push(midLineCharMatch[1].trim());
            normalizedLines.push('- ' + midLineCharMatch[2].trim());
        } else {
            normalizedLines.push(line);
        }
    }

    for (const line of normalizedLines) {
        lineNumber++;

        // Skip empty lines, headers, dividers, and code fences
        if (!line.trim() ||
            line.includes('Present Characters') ||
            line.includes('---') ||
            line.trim().startsWith('```') ||
            line.trim() === '- ‚Ä¶' ||
            line.includes('(Repeat the format')) {
            continue;
        }

        debugLog(`[RPG Thoughts] Processing line ${lineNumber}:`, line);

        // Check if this is a character name line (starts with "- ")
        if (line.trim().startsWith('- ')) {
            const name = line.trim().substring(2).trim();

            if (name && name.toLowerCase() !== 'unavailable') {
                currentCharacter = { name };
                presentCharacters.push(currentCharacter);
                debugLog(`[RPG Thoughts] ‚úì Started new character: ${name}`);
            } else {
                currentCharacter = null;
                debugLog(`[RPG Thoughts] ‚úó Rejected character - name: "${name}" (unavailable or empty)`);
            }
        }
        // Check if this is a Details line
        else if (line.trim().startsWith('Details:') && currentCharacter) {
            const detailsContent = line.substring(line.indexOf(':') + 1).trim();
            const parts = detailsContent.split('|').map(p => p.trim());

            // First part is the emoji
            if (parts.length > 0) {
                currentCharacter.emoji = parts[0];
                debugLog(`[RPG Thoughts] Parsed emoji: ${parts[0]}`);
            }

            // Remaining parts are custom fields
            for (let i = 0; i < enabledFields.length && i + 1 < parts.length; i++) {
                const fieldName = enabledFields[i].name;
                currentCharacter[fieldName] = parts[i + 1];
                debugLog(`[RPG Thoughts] Parsed field ${fieldName}: ${parts[i + 1]}`);
            }
        }
        // Check if this is a Relationship line
        else if (line.trim().startsWith('Relationship:') && currentCharacter) {
            const relationship = line.substring(line.indexOf(':') + 1).trim();
            currentCharacter.Relationship = relationship;
            debugLog(`[RPG Thoughts] Parsed relationship: ${relationship}`);
        }
        // Check if this is a Stats line
        else if (line.trim().startsWith('Stats:') && currentCharacter && enabledCharStats.length > 0) {
            const statsContent = line.substring(line.indexOf(':') + 1).trim();
            const statParts = statsContent.split('|').map(p => p.trim());

            for (const statPart of statParts) {
                const statMatch = statPart.match(/^(.+?):\s*(\d+)%$/);
                if (statMatch) {
                    const statName = statMatch[1].trim();
                    const statValue = parseInt(statMatch[2]);
                    currentCharacter[statName] = statValue;
                    debugLog(`[RPG Thoughts] Parsed stat: ${statName} = ${statValue}%`);
                }
            }
        }
        // Check if this is a Thoughts line (handled separately for thought bubbles)
        else if (line.trim().match(/^[A-Z][a-z]+:/) && currentCharacter) {
            // This could be Thoughts, Feelings, etc. - skip for now, handled in thought bubble rendering
            debugLog(`[RPG Thoughts] Skipping thoughts/feelings line (handled in bubble rendering)`);
        }
    }

    // Get relationship emojis from config (with fallback defaults)
    const relationshipEmojis = config?.relationshipEmojis || {
        'Enemy': '‚öîÔ∏è',
        'Neutral': '‚öñÔ∏è',
        'Friend': '‚≠ê',
        'Lover': '‚ù§Ô∏è'
    };
    debugLog('[RPG Thoughts] ==================== PARSING COMPLETE ====================');
    debugLog('[RPG Thoughts] Total characters parsed:', presentCharacters.length);
    debugLog('[RPG Thoughts] Characters array:', presentCharacters);

    // Build HTML
    let html = '';

    // Add section header with buttons
    html += `
        <div class="rpg-section-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <h4 style="margin: 0;">Present Characters</h4>
            <div style="display: flex; gap: 4px;">
                <button id="rpg-regenerate-present-characters" class="rpg-btn-icon" title="Regenerate Present Characters" style="padding: 4px 8px; font-size: 14px;">
                    <i class="fa-solid fa-rotate"></i>
                </button>
                <button id="rpg-generate-new-character" class="rpg-btn-icon" title="Generate New Character with AI" style="padding: 4px 8px; font-size: 14px;">
                    <i class="fa-solid fa-wand-magic-sparkles"></i>
                </button>
                <button id="rpg-open-character-editor" class="rpg-btn-icon" title="Advanced Character Editor" style="padding: 4px 8px; font-size: 14px;">
                    <i class="fa-solid fa-users-gear"></i>
                </button>
            </div>
        </div>
    `;

    debugLog('[RPG Thoughts] ==================== BUILDING HTML ====================');
    debugLog('[RPG Thoughts] Starting HTML generation for', presentCharacters.length + ' characters');

    // If no characters parsed, show a placeholder editable card (if narrator mode is disabled)
    if (presentCharacters.length === 0 && !extensionSettings.narratorMode) {
        debugLog('[RPG Thoughts] ‚ö† No characters parsed - showing placeholder card');
        // Get default character portrait
        let defaultPortrait = FALLBACK_AVATAR_DATA_URI;
        let defaultName = 'Character';

        if (this_chid !== undefined && characters[this_chid]) {
            if (characters[this_chid].avatar && characters[this_chid].avatar !== 'none') {
                const thumbnailUrl = getSafeThumbnailUrl('avatar', characters[this_chid].avatar);
                if (thumbnailUrl) {
                    defaultPortrait = thumbnailUrl;
                }
            }
            defaultName = characters[this_chid].name || 'Character';
        }

        const escapedDefaultName = escapeHtmlAttr(defaultName);

        // Determine right-click action text based on auto-generate setting
        const defaultAvatarRightClickAction = extensionSettings.autoGenerateAvatars 
            ? 'Right-click to regenerate avatar' 
            : 'Right-click to delete avatar';

        html += '<div class="rpg-thoughts-content">';
        html += `
            <div class="rpg-character-card" data-character-name="${escapedDefaultName}">
                <div class="rpg-character-avatar rpg-avatar-upload" data-character="${escapedDefaultName}" title="Click to upload custom avatar&#10;${defaultAvatarRightClickAction}">
                    <img src="${defaultPortrait}" alt="${escapedDefaultName}" onerror="this.style.opacity='0.5';this.onerror=null;" />
                    <div class="rpg-relationship-badge rpg-editable" contenteditable="true" data-character="${escapedDefaultName}" data-field="relationship" title="Click to edit (use emoji: ‚öîÔ∏è ‚öñÔ∏è ‚≠ê ‚ù§Ô∏è)">‚öñÔ∏è</div>
                </div>
                <div class="rpg-character-info">
                    <div class="rpg-character-header">
                        <span class="rpg-character-emoji rpg-editable" contenteditable="true" data-character="${escapedDefaultName}" data-field="emoji" title="Click to edit emoji">üòä</span>
                        <span class="rpg-character-name rpg-editable" contenteditable="true" data-character="${escapedDefaultName}" data-field="name" title="Click to edit name">${defaultName}</span>
                    </div>
        `;

        // Add custom fields dynamically
        for (const field of enabledFields) {
            const fieldId = field.name.toLowerCase().replace(/\s+/g, '-');
            html += `
                    <div class="rpg-character-field rpg-character-${fieldId} rpg-editable" contenteditable="true" data-character="${escapedDefaultName}" data-field="${escapeHtmlAttr(field.name)}" title="Click to edit ${field.name}"></div>
            `;
        }

        html += `
                </div>
            </div>
        `;
        html += '</div>';
    } else {
        html += '<div class="rpg-thoughts-content">';

        let characterIndex = 0;
        for (const char of presentCharacters) {
            characterIndex++;

            try {
                debugLog(`[RPG Thoughts] Building HTML for character ${characterIndex}/${presentCharacters.length}:`, char.name);

                // Find character portrait using the new helper function
                const characterPortrait = getCharacterAvatar(char.name);

                debugLog(`[RPG Thoughts] Final avatar for ${char.name}:`, typeof characterPortrait === 'string' ? characterPortrait.substring(0, 50) + '...' : characterPortrait);

                // Get relationship badge - only if relationships are enabled in config
                let relationshipBadgeHtml = '‚öñÔ∏è'; // Default
                let relationshipFieldName = 'Relationship';

                if (hasRelationshipEnabled) {
                    // In the new format, relationship is always stored in char.Relationship
                    if (char.Relationship) {
                        // Try to map text to emoji
                        const relationshipValue = relationshipEmojis[char.Relationship] || char.Relationship;
                        relationshipBadgeHtml = renderRelationshipBadge(relationshipValue);
                    } else {
                        relationshipBadgeHtml = renderRelationshipBadge('‚öñÔ∏è');
                    }
                }

                debugLog(`[RPG Thoughts] Building HTML card for ${char.name}...`);

                // Escape character name for use in HTML attributes
                const escapedName = escapeHtmlAttr(char.name);

                // Check if avatar is being generated
                const isCurrentlyGenerating = isGenerating(char.name);

                // Determine right-click action text based on auto-generate setting
                const avatarRightClickAction = extensionSettings.autoGenerateAvatars
                    ? 'Right-click to regenerate avatar'
                    : 'Right-click to delete avatar';

                // Check if character is pinned
                const isPinned = extensionSettings.pinnedCharacters &&
                    extensionSettings.pinnedCharacters.some(name => name.toLowerCase() === char.name.toLowerCase());
                const pinClass = isPinned ? 'rpg-character-pinned' : '';
                const pinTitle = isPinned
                    ? 'Unpin this character (currently protected from regeneration removal)'
                    : 'Pin this character to prevent removal during regeneration';

                // Check if character is frozen
                const isFrozen = extensionSettings.frozenCharacters &&
                    extensionSettings.frozenCharacters[char.name.toLowerCase()];
                const freezeClass = isFrozen ? 'rpg-character-frozen' : '';
                const freezeTitle = isFrozen
                    ? 'Unfreeze this character (currently locked - no updates during regeneration)'
                    : 'Freeze this character to lock their state and prevent any updates';

                html += `
                    <div class="rpg-character-card ${pinClass} ${freezeClass}" data-character-name="${escapedName}">
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <div class="rpg-character-avatar rpg-avatar-upload ${isCurrentlyGenerating ? 'rpg-avatar-generating' : ''}" data-character="${escapedName}" title="Click to upload custom avatar&#10;${avatarRightClickAction}">
                                <img src="${characterPortrait}" alt="${escapedName}" onerror="this.style.opacity='0.5';this.onerror=null;" />
                                ${isCurrentlyGenerating ? '<div class="rpg-generating-overlay"><i class="fa-solid fa-spinner fa-spin"></i></div>' : ''}
                                ${hasRelationshipEnabled ? `<div class="rpg-relationship-badge rpg-editable" contenteditable="true" data-character="${escapedName}" data-field="${relationshipFieldName}" title="Click to edit (use emoji: ‚öîÔ∏è ‚öñÔ∏è ‚≠ê ‚ù§Ô∏è)">${relationshipBadgeHtml}</div>` : ''}
                            </div>
                            <button class="rpg-create-char-card-btn" data-character="${escapedName}" title="Create Character Card from this NPC" style="width: 90%; padding: 3px 6px; margin-top: 4px; font-size: 10px; background: #4a90e2; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                <i class="fa-solid fa-id-card"></i> Card
                            </button>
                        </div>
                        <div class="rpg-character-content">
                            <div class="rpg-character-info">
                                <div class="rpg-character-header">
                                    <span class="rpg-character-emoji rpg-editable" contenteditable="true" data-character="${escapedName}" data-field="emoji" title="Click to edit emoji">${char.emoji}</span>
                                    <span class="rpg-character-name rpg-editable" contenteditable="true" data-character="${escapedName}" data-field="name" title="Click to edit name">${char.name}</span>
                                    <button class="rpg-character-pin ${pinClass}" data-character="${escapedName}" title="${pinTitle}">üìå</button>
                                    <button class="rpg-character-freeze ${freezeClass}" data-character="${escapedName}" title="${freezeTitle}">‚ùÑÔ∏è</button>
                                    <button class="rpg-character-regen" data-character="${escapedName}" title="Regenerate this character">üîÑ</button>
                                    <button class="rpg-character-remove" data-character="${escapedName}" title="Remove this character from the panel">√ó</button>
                                </div>
                `;

                // Render custom fields dynamically
                for (const field of enabledFields) {
                    const fieldValue = char[field.name] || '';
                    const fieldId = field.name.toLowerCase().replace(/\s+/g, '-');
                    html += `
                                <div class="rpg-character-field rpg-character-${fieldId} rpg-editable" contenteditable="true" data-character="${escapedName}" data-field="${escapeHtmlAttr(field.name)}" title="Click to edit ${field.name}">${fieldValue}</div>
                    `;
                }

                html += `
                            </div>
                `;

                // Render character stats if enabled (outside rpg-character-info)
                if (enabledCharStats.length > 0) {
                    html += `<div class="rpg-character-stats"><div class="rpg-character-stats-inner">`;
                    for (const stat of enabledCharStats) {
                        const statValue = char[stat.name] || 0;
                        const statColor = getStatColor(statValue, extensionSettings.statBarColorLow, extensionSettings.statBarColorHigh);
                        html += `
                                <div class="rpg-character-stat">
                                    <span class="rpg-stat-name">${stat.name}: </span><span class="rpg-editable" contenteditable="true" data-character="${escapedName}" data-field="${escapeHtmlAttr(stat.name)}" style="color: ${statColor}" title="Click to edit ${stat.name}">${statValue}%</span>
                                </div>
                        `;
                    }
                    html += `</div></div>`;
                }

                html += `
                        </div>
                    </div>
                `;

                debugLog(`[RPG Thoughts] ‚úì Successfully built HTML for ${char.name}`);

            } catch (charError) {
                debugLog(`[RPG Thoughts] ‚úó ERROR building HTML for ${char.name}:`, charError.message);
                debugLog('[RPG Thoughts] Error stack:', charError.stack);
                // Continue with next character instead of crashing
            }
        }

        debugLog('[RPG Thoughts] Finished building all character cards');
        html += '</div>';
    }

    $thoughtsContainer.html(html);

    debugLog('[RPG Thoughts] ‚úì HTML rendered to container');
    debugLog('[RPG Thoughts] =======================================================');

    // Add event handler for regenerate button (with optional guidance)
    $('#rpg-regenerate-present-characters').off('click').on('click', async function() {
        try {
            const { showTrackerRegenerationModal } = await import('../ui/trackerRegeneration.js');
            showTrackerRegenerationModal('presentCharacters');
        } catch (error) {
            console.error('[RPG Companion] Failed to load tracker regeneration module:', error);
            toastr.error('Failed to open regeneration dialog: ' + error.message, 'RPG Companion');
        }
    });

    // Add event handler for generate new character button
    $('#rpg-generate-new-character').off('click').on('click', async function() {
        try {
            console.log('[RPG Companion] Loading character creator module...');
            const module = await import('../ui/characterCreatorUI.js');
            console.log('[RPG Companion] Opening character creator...');
            module.openCharacterCreatorModal();
        } catch (err) {
            console.error('[RPG Companion] Failed to load character creator:', err);
            console.error('[RPG Companion] Error stack:', err.stack);
            toastr.error('Failed to open character creator: ' + err.message, 'RPG Companion');
        }
    });

    // Add event handler for character editor button
    $('#rpg-open-character-editor').off('click').on('click', async function() {
        try {
            console.log('[RPG Companion] Loading character editor module...');
            // Import dynamically to avoid circular dependencies
            const module = await import('../ui/characterEditor.js');
            console.log('[RPG Companion] Module loaded:', module);
            console.log('[RPG Companion] Calling openCharacterEditor...');
            module.openCharacterEditor();
        } catch (err) {
            console.error('[RPG Companion] Failed to load character editor:', err);
            console.error('[RPG Companion] Error stack:', err.stack);
            toastr.error('Failed to open character editor: ' + err.message, 'RPG Companion');
        }
    });

    // Add event handlers for editable character fields
    $thoughtsContainer.find('.rpg-editable').on('blur', function() {
        const $element = $(this);
        const oldCharacterName = $element.data('character');
        const field = $element.data('field');
        const value = $element.text().trim();
        console.log('[RPG Companion] Character field edit:', { character: oldCharacterName, field, value });

        // Update the data
        updateCharacterField(oldCharacterName, field, value);

        // If we're editing the name field, update all data-character attributes for this character
        if (field === 'name' && value !== oldCharacterName) {
            const $characterCard = $element.closest('.rpg-character-card');
            if ($characterCard.length > 0) {
                // Update all elements within this character card that have data-character attribute
                $characterCard.find(`[data-character="${oldCharacterName}"]`).each(function() {
                    $(this).attr('data-character', value);
                    $(this).data('character', value); // Update jQuery data cache
                });
                // Also update the card's data-character-name attribute
                $characterCard.attr('data-character-name', value);
                console.log('[RPG Companion] Updated data-character attributes from', oldCharacterName, 'to', value);
            }
        }
    });

    // Add emoji picker for character emoji fields (not relationship badge - it has auto text-to-emoji conversion)
    $thoughtsContainer.find('.rpg-character-emoji').on('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const $element = $(this);

        // Import and call the emoji picker
        import('../ui/trackerEditor.js').then(module => {
            if (module.openEmojiPicker) {
                // Create a temporary input to hold the value
                const currentValue = $element.text().trim();
                const $tempInput = $('<input type="text" style="position: absolute; opacity: 0; pointer-events: none;">');
                $tempInput.val(currentValue);
                $element.after($tempInput);

                // Position the temp input at the element's location for picker positioning
                const rect = $element[0].getBoundingClientRect();
                $tempInput.css({
                    position: 'fixed',
                    top: rect.top + 'px',
                    left: rect.left + 'px'
                });

                // Override blur handler to update the contenteditable element
                $tempInput.on('blur', function() {
                    const newValue = $(this).val();
                    if (newValue) {
                        $element.text(newValue);
                        // Trigger the original blur handler to save
                        $element.trigger('blur');
                    }
                    $tempInput.remove();
                });

                module.openEmojiPicker($tempInput);
            }
        });
    });

    // Add event handler for avatar uploads
    $thoughtsContainer.find('.rpg-avatar-upload').on('click', function(e) {
        // Prevent triggering if clicking on the relationship badge
        if ($(e.target).hasClass('rpg-relationship-badge') || $(e.target).closest('.rpg-relationship-badge').length > 0) {
            return;
        }

        const characterName = $(this).data('character');
        console.log('[RPG Companion] Avatar upload clicked for:', characterName);
        uploadNpcAvatar(characterName);
    });

    // Add event handler for regenerating avatars (right-click)
    $thoughtsContainer.find('.rpg-avatar-upload').on('contextmenu', async function(e) {
        // Prevent triggering if clicking on the relationship badge
        if ($(e.target).hasClass('rpg-relationship-badge') || $(e.target).closest('.rpg-relationship-badge').length > 0) {
            return;
        }

        e.preventDefault(); // Prevent default context menu
        const characterName = $(this).data('character');
        const $avatarEl = $(this);

        // Check if auto-generation is enabled
        if (!extensionSettings.autoGenerateAvatars) {
            // If auto-generation is disabled, just remove the custom avatar
            if (extensionSettings.npcAvatars && extensionSettings.npcAvatars[characterName]) {
                delete extensionSettings.npcAvatars[characterName];
                saveSettings();
                console.log(`[RPG Companion] Removed custom avatar for: ${characterName}`);

                // Preserve scroll position before re-rendering
                const scrollTop = $thoughtsContainer ? $thoughtsContainer.scrollTop() : 0;
                renderThoughts();
                // Restore scroll position after re-rendering (use setTimeout to ensure DOM is updated)
                if ($thoughtsContainer && scrollTop > 0) {
                    setTimeout(() => {
                        $thoughtsContainer.scrollTop(scrollTop);
                    }, 0);
                }
            }
            return;
        }

        // Show generating state with spinner overlay
        $avatarEl.addClass('rpg-avatar-generating');
        if (!$avatarEl.find('.rpg-generating-overlay').length) {
            $avatarEl.append('<div class="rpg-generating-overlay"><i class="fa-solid fa-spinner fa-spin"></i></div>');
        }
        console.log(`[RPG Companion] Regenerating avatar for: ${characterName}`);

        try {
            // Regenerate the avatar
            const newUrl = await regenerateAvatar(characterName);
            
            if (newUrl) {
                console.log(`[RPG Companion] Successfully regenerated avatar for: ${characterName}`);
            } else {
                console.warn(`[RPG Companion] Failed to regenerate avatar for: ${characterName}`);
            }
        } catch (error) {
            console.error(`[RPG Companion] Error regenerating avatar for ${characterName}:`, error);
        }

        // Re-render to show the new avatar (or fallback)
        // Preserve scroll position before re-rendering
        const scrollTop = $thoughtsContainer ? $thoughtsContainer.scrollTop() : 0;
        renderThoughts();
        // Restore scroll position after re-rendering (use setTimeout to ensure DOM is updated)
        if ($thoughtsContainer && scrollTop > 0) {
            setTimeout(() => {
                $thoughtsContainer.scrollTop(scrollTop);
            }, 0);
        }
    });

    // Add event handler for character pinning
    $thoughtsContainer.find('.rpg-character-pin').on('click', function(e) {
        e.stopPropagation(); // Prevent event bubbling
        const characterName = $(this).data('character');
        togglePinCharacter(characterName);
    });

    // Add event handler for character freezing
    $thoughtsContainer.find('.rpg-character-freeze').on('click', function(e) {
        e.stopPropagation(); // Prevent event bubbling
        const characterName = $(this).data('character');
        toggleFreezeCharacter(characterName);
    });

    // Add event handler for character regeneration
    $thoughtsContainer.find('.rpg-character-regen').on('click', function(e) {
        e.stopPropagation(); // Prevent event bubbling
        const characterName = $(this).data('character');
        regenerateCharacterFromCard(characterName);
    });

    // Add event handler for create character card button
    $thoughtsContainer.find('.rpg-create-char-card-btn').on('click', async function(e) {
        e.stopPropagation(); // Prevent event bubbling
        const characterName = $(this).data('character');

        try {
            console.log('[RPG Companion] Loading character creator for:', characterName);
            const module = await import('../ui/characterCreatorUI.js');

            // Find the character data from presentCharacters
            const charData = presentCharacters.find(c => c.name === characterName);
            console.log('[RPG Companion] Opening character creator with data:', charData);
            module.openCharacterCreatorModal(charData);
        } catch (err) {
            console.error('[RPG Companion] Failed to load character creator:', err);
            toastr.error('Failed to open character creator: ' + err.message, 'RPG Companion');
        }
    });

    // Add event handler for character removal
    $thoughtsContainer.find('.rpg-character-remove').on('click', function(e) {
        e.stopPropagation(); // Prevent event bubbling
        const characterName = $(this).data('character');
        removeCharacter(characterName);
    });

    // Remove updating class after animation
    if (extensionSettings.enableAnimations) {
        setTimeout(() => $thoughtsContainer.removeClass('rpg-content-updating'), 600);
    }

    // Update chat overlay if enabled
    if (extensionSettings.showThoughtsInChat) {
        updateChatThoughts();
    }
}

/**
 * Updates a specific character field in Present Characters data and re-renders.
 * Works with the new multi-line format.
 *
 * @param {string} characterName - Name of the character to update
 * @param {string} field - Field to update (emoji, name, custom field name, Relationship, stat name)
 * @param {string} value - New value for the field
 */
export function updateCharacterField(characterName, field, value) {
    // Validate inputs
    if (!characterName || typeof characterName !== 'string') {
        console.error('[RPG Companion] Invalid character name for update:', characterName);
        return;
    }

    if (!field || typeof field !== 'string') {
        console.error('[RPG Companion] Invalid field name for update:', field);
        return;
    }

    // Initialize if it doesn't exist
    if (!lastGeneratedData.characterThoughts) {
        lastGeneratedData.characterThoughts = 'Present Characters\n---\n';
    }

    const lines = lastGeneratedData.characterThoughts.split('\n');
    const presentCharsConfig = extensionSettings.trackerConfig?.presentCharacters;
    const enabledFields = presentCharsConfig?.customFields?.filter(f => f && f.enabled && f.name) || [];
    const characterStats = presentCharsConfig?.characterStats;
    const enabledCharStats = characterStats?.enabled && characterStats?.customStats?.filter(s => s && s.enabled && s.name) || [];

    let characterFound = false;
    let inTargetCharacter = false;
    let characterStartIndex = -1;
    let characterEndIndex = -1;
    let matchedCharacterName = null;

    // Find the character block - use exact match first, then case-insensitive
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line.startsWith('- ')) {
            const name = line.substring(2).trim();
            // Try exact match first
            if (name === characterName) {
                characterFound = true;
                inTargetCharacter = true;
                characterStartIndex = i;
                matchedCharacterName = name;
                break;
            }
        }
    }

    // If no exact match, try case-insensitive
    if (!characterFound) {
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            if (line.startsWith('- ')) {
                const name = line.substring(2).trim();
                if (name.toLowerCase() === characterName.toLowerCase()) {
                    characterFound = true;
                    inTargetCharacter = true;
                    characterStartIndex = i;
                    matchedCharacterName = name;
                    console.warn('[RPG Companion] Character name case mismatch:', { searched: characterName, found: name });
                    break;
                }
            }
        }
    }

    // Find the end of the character block
    if (characterFound) {
        for (let i = characterStartIndex + 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.startsWith('- ')) {
                characterEndIndex = i;
                break;
            }
        }
    }

    if (characterFound && characterEndIndex === -1) {
        characterEndIndex = lines.length;
    }

    if (!characterFound) {
        console.error('[RPG Companion] Character not found for update:', {
            searchedName: characterName,
            field: field,
            value: value,
            availableCharacters: lines.filter(l => l.trim().startsWith('- ')).map(l => l.substring(2).trim())
        });
        return;
    }

    if (characterFound) {
        // Check if we're updating a character stat
        const isStatField = enabledCharStats.findIndex(s => s.name === field) !== -1;
        let statsLineExists = false;
        let statsLineIndex = -1;

        // Get the configured thoughts field name
        const thoughtsFieldName = presentCharsConfig?.thoughts?.name || 'Thoughts';
        const isThoughtsField = field.toLowerCase() === 'thoughts' || field === thoughtsFieldName;

        // First pass: check if Stats line exists and update other fields
        for (let i = characterStartIndex; i < characterEndIndex; i++) {
            const line = lines[i].trim();

            if (line.startsWith('Stats:')) {
                statsLineExists = true;
                statsLineIndex = i;
            }

            if (field === 'name' && line.startsWith('- ')) {
                lines[i] = `- ${value}`;
            }
            else if (field === 'emoji' && line.startsWith('Details:')) {
                const parts = line.substring(line.indexOf(':') + 1).split('|').map(p => p.trim());
                parts[0] = value;
                lines[i] = `Details: ${parts.join(' | ')}`;
            }
            else if (line.startsWith('Details:')) {
                const fieldIndex = enabledFields.findIndex(f => f.name === field);
                if (fieldIndex !== -1) {
                    const parts = line.substring(line.indexOf(':') + 1).split('|').map(p => p.trim());
                    if (parts.length > fieldIndex + 1) {
                        parts[fieldIndex + 1] = value;
                        lines[i] = `Details: ${parts.join(' | ')}`;
                    }
                }
            }
            else if (field === 'Relationship' && line.startsWith('Relationship:')) {
                const emojiToRelationship = { '‚öîÔ∏è': 'Enemy', '‚öñÔ∏è': 'Neutral', '‚≠ê': 'Friend', '‚ù§Ô∏è': 'Lover' };
                const relationshipValue = emojiToRelationship[value] || value;
                lines[i] = `Relationship: ${relationshipValue}`;
            }
            else if (isThoughtsField && line.startsWith(thoughtsFieldName + ':')) {
                // Update thoughts field
                lines[i] = `${thoughtsFieldName}: ${value}`;
                console.log('[RPG Companion] Updated thoughts:', lines[i]);
            }
        }

        // Handle stat updates
        if (isStatField) {
            // Clean the value: remove % if present, parse as integer, clamp 0-100
            let cleanValue = value.replace('%', '').trim();
            let numValue = parseInt(cleanValue);
            if (isNaN(numValue)) {
                numValue = 0;
            }
            numValue = Math.max(0, Math.min(100, numValue));

            console.log('[RPG Companion] Updating stat:', { field, rawValue: value, cleanValue, numValue });

            if (statsLineExists) {
                // Update existing Stats line
                const line = lines[statsLineIndex];
                const statsContent = line.substring(line.indexOf(':') + 1).trim();
                const statParts = statsContent.split('|').map(p => p.trim());

                let statFound = false;
                for (let j = 0; j < statParts.length; j++) {
                    if (statParts[j].startsWith(field + ':')) {
                        statParts[j] = `${field}: ${numValue}%`;
                        statFound = true;
                        console.log('[RPG Companion] Updated stat part:', statParts[j]);
                        break;
                    }
                }

                // If stat wasn't found in existing parts, add it
                if (!statFound) {
                    statParts.push(`${field}: ${numValue}%`);
                    console.log('[RPG Companion] Added new stat to existing line:', `${field}: ${numValue}%`);
                }

                lines[statsLineIndex] = `Stats: ${statParts.join(' | ')}`;
                console.log('[RPG Companion] Updated stats line:', lines[statsLineIndex]);
            } else {
                // Create new Stats line with all enabled stats (defaulting to 0% except the one being edited)
                const statsParts = enabledCharStats.map(s => {
                    if (s.name === field) {
                        return `${s.name}: ${numValue}%`;
                    }
                    return `${s.name}: 0%`;
                });
                const newStatsLine = `Stats: ${statsParts.join(' | ')}`;

                // Insert before Thoughts line or at end of character block
                let insertIndex = characterEndIndex;
                for (let i = characterStartIndex; i < characterEndIndex; i++) {
                    const line = lines[i].trim();
                    const thoughtsFieldName = presentCharsConfig?.thoughts?.name || 'Thoughts';
                    if (line.startsWith(thoughtsFieldName + ':')) {
                        insertIndex = i;
                        break;
                    }
                }

                lines.splice(insertIndex, 0, newStatsLine);
                console.log('[RPG Companion] Created new stats line:', newStatsLine);
                characterEndIndex++; // Adjust end index since we inserted a line
            }
        }
    } else {
        // Create new character block
        const dividerIndex = lines.findIndex(line => line.includes('---'));
        if (dividerIndex >= 0) {
            const newCharacterLines = [`- ${characterName}`];

            let detailsParts = [field === 'emoji' ? value : 'üòä'];
            for (let i = 0; i < enabledFields.length; i++) {
                detailsParts.push(field === enabledFields[i].name ? value : '');
            }
            newCharacterLines.push(`Details: ${detailsParts.join(' | ')}`);

            if (presentCharsConfig?.relationshipFields?.length > 0) {
                const emojiToRelationship = { '‚öîÔ∏è': 'Enemy', '‚öñÔ∏è': 'Neutral', '‚≠ê': 'Friend', '‚ù§Ô∏è': 'Lover' };
                const relationshipValue = field === 'Relationship' ? (emojiToRelationship[value] || value) : 'Neutral';
                newCharacterLines.push(`Relationship: ${relationshipValue}`);
            }

            if (enabledCharStats.length > 0) {
                const statsParts = enabledCharStats.map(s => {
                    if (field === s.name) {
                        // Clean the value: remove % if present, parse as integer, clamp 0-100
                        let cleanValue = value.replace('%', '').trim();
                        let numValue = parseInt(cleanValue);
                        if (isNaN(numValue)) {
                            numValue = 0;
                        }
                        numValue = Math.max(0, Math.min(100, numValue));
                        return `${s.name}: ${numValue}%`;
                    }
                    return `${s.name}: 0%`;
                });
                newCharacterLines.push(`Stats: ${statsParts.join(' | ')}`);
            }

            lines.splice(dividerIndex + 1, 0, ...newCharacterLines);
        }
    }

    lastGeneratedData.characterThoughts = lines.join('\n');
    committedTrackerData.characterThoughts = lines.join('\n');

    console.log('[RPG Companion] Updated characterThoughts data:', lastGeneratedData.characterThoughts);

    const chat = getContext().chat;
    if (chat && chat.length > 0) {
        for (let i = chat.length - 1; i >= 0; i--) {
            const message = chat[i];
            if (!message.is_user) {
                if (message.extra && message.extra.rpg_companion_swipes) {
                    const swipeId = message.swipe_id || 0;
                    if (message.extra.rpg_companion_swipes[swipeId]) {
                        message.extra.rpg_companion_swipes[swipeId].characterThoughts = lines.join('\n');
                    }
                }
                break;
            }
        }
    }

    saveChatData();

    // DON'T re-render the entire panel - the data is already updated in the DOM
    // Just update the chat thoughts overlay if needed
    const thoughtsFieldName = presentCharsConfig?.thoughts?.name || 'Thoughts';
    if (field === thoughtsFieldName || field.toLowerCase() === 'thoughts') {
        setTimeout(() => updateChatThoughts(), 100);
    } else {
        updateChatThoughts();
    }

    console.log('[RPG Companion] Character field updated without re-rendering panel');
}

/**
 * Updates or removes thought overlays in the chat.
 * Creates floating thought bubbles positioned near character avatars.
 */
export function updateChatThoughts() {
    // console.log('[RPG Companion] ======== updateChatThoughts called ========');
    // console.log('[RPG Companion] Extension enabled:', extensionSettings.enabled);
    // console.log('[RPG Companion] showThoughtsInChat setting:', extensionSettings.showThoughtsInChat);
    // console.log('[RPG Companion] Toggle element checked:', $('#rpg-toggle-thoughts-in-chat').prop('checked'));
    // console.log('[RPG Companion] lastGeneratedData.characterThoughts:', lastGeneratedData.characterThoughts);

    // Check if panel already exists (to skip animation on updates)
    const $existingPanel = $('#rpg-thought-panel');
    const panelAlreadyExists = $existingPanel.length > 0;

    // Save scroll position before removing the panel
    const $existingBubble = $('#rpg-thought-panel .rpg-thought-bubble');
    const savedScrollTop = $existingBubble.length ? $existingBubble.scrollTop() : 0;

    // Remove existing thought panel and icon
    $('#rpg-thought-panel').remove();
    $('#rpg-thought-icon').remove();
    $('#chat').off('scroll.thoughtPanel');
    $(window).off('resize.thoughtPanel');
    $(document).off('click.thoughtPanel');

    // If extension is disabled, thoughts in chat are disabled, or no thoughts, just return
    if (!extensionSettings.enabled || !extensionSettings.showThoughtsInChat || !lastGeneratedData.characterThoughts) {
        // console.log('[RPG Companion] Thoughts in chat disabled or no data');
        return;
    }

    // Parse the Present Characters data to get thoughts
    const lines = lastGeneratedData.characterThoughts.split('\n');
    const thoughtsArray = []; // Array of {name, emoji, thought}
    const thoughtsConfig = extensionSettings.trackerConfig?.presentCharacters?.thoughts;
    const thoughtsLabel = thoughtsConfig?.name || 'Thoughts';

    // console.log('[RPG Companion] Parsing thoughts from lines:', lines);

    // Parse new format to build character map and thoughts
    let currentCharName = null;
    let currentCharEmoji = null;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (!line ||
            line.includes('Present Characters') ||
            line.includes('---') ||
            line.startsWith('```') ||
            line.trim() === '- ‚Ä¶' ||
            line.includes('(Repeat the format')) {
            continue;
        }

        // Check if this is a character name line (starts with "- ")
        if (line.startsWith('- ')) {
            const name = line.substring(2).trim();
            if (name && name.toLowerCase() !== 'unavailable') {
                currentCharName = name;
                currentCharEmoji = null; // Reset emoji for new character
            } else {
                currentCharName = null;
                currentCharEmoji = null;
            }
        }
        // Check if this is a Details line (contains the emoji)
        else if (line.startsWith('Details:') && currentCharName) {
            const detailsContent = line.substring(line.indexOf(':') + 1).trim();
            const parts = detailsContent.split('|').map(p => p.trim());

            // First part is the emoji
            if (parts.length > 0) {
                currentCharEmoji = parts[0];
            }
        }
        // Check if this is a Thoughts line
        else if (line.startsWith(thoughtsLabel + ':') && currentCharName && currentCharEmoji) {
            const thoughtContent = line.substring(thoughtsLabel.length + 1).trim();

            // The thought content is just the text (no emoji prefix in new format)
            if (thoughtContent) {
                thoughtsArray.push({
                    name: currentCharName.toLowerCase(),
                    emoji: currentCharEmoji,
                    thought: thoughtContent
                });
            }
        }
    }

    debugLog('[RPG Thoughts] Parsed thoughts:', thoughtsArray);

    // If no thoughts parsed, return
    if (thoughtsArray.length === 0) {
        // console.log('[RPG Companion] No thoughts parsed, returning');
        return;
    }

    // console.log('[RPG Companion] Total thoughts:', thoughtsArray.length);
    // console.log('[RPG Companion] Thoughts array:', thoughtsArray);

    // Find the last message to position near
    const $messages = $('#chat .mes');
    let $targetMessage = null;

    // Find the most recent non-user message
    for (let i = $messages.length - 1; i >= 0; i--) {
        const $message = $messages.eq(i);
        if ($message.attr('is_user') !== 'true') {
            $targetMessage = $message;
            break;
        }
    }

    if (!$targetMessage) {
        // console.log('[RPG Companion] No target message found');
        return;
    }

    // Create the thought panel with all thoughts
    createThoughtPanel($targetMessage, thoughtsArray, panelAlreadyExists);

    // Restore scroll position after panel is created (use setTimeout to ensure DOM is updated)
    if (savedScrollTop > 0) {
        setTimeout(() => {
            const $newBubble = $('#rpg-thought-panel .rpg-thought-bubble');
            if ($newBubble.length) {
                $newBubble.scrollTop(savedScrollTop);
            }
        }, 0);
    }
}

/**
 * Creates or updates the floating thought panel positioned next to the character's avatar.
 * Handles responsive positioning for left/right panel modes and mobile viewports.
 *
 * @param {jQuery} $message - Message element to position the panel relative to
 * @param {Array} thoughtsArray - Array of thought objects {name, emoji, thought}
 * @param {boolean} skipAnimation - If true, skip the fade-in animation (for updates)
 */
export function createThoughtPanel($message, thoughtsArray, skipAnimation = false) {
    // Remove existing thought panel
    $('#rpg-thought-panel').remove();
    $('#rpg-thought-icon').remove();

    // Get the avatar position from the message
    const $avatar = $message.find('.avatar img');
    if (!$avatar.length) {
        // console.log('[RPG Companion] No avatar found in message');
        return;
    }

    const avatarRect = $avatar[0].getBoundingClientRect();
    const panelPosition = extensionSettings.panelPosition;
    const theme = extensionSettings.theme;

    // Build thought bubbles HTML
    let thoughtsHtml = '';
    thoughtsArray.forEach((thought, index) => {
        const escapedThoughtName = escapeHtmlAttr(thought.name);
        thoughtsHtml += `
            <div class="rpg-thought-item">
                <div class="rpg-thought-emoji-box">
                    ${thought.emoji}
                    <button class="rpg-thought-regen-btn" data-character="${escapedThoughtName}" title="Regenerate thought">üîÑ</button>
                </div>
                <div class="rpg-thought-content rpg-editable" contenteditable="true" data-character="${escapedThoughtName}" data-field="thoughts" title="Click to edit thoughts">
                    ${thought.thought}
                </div>
            </div>
        `;
        // Add divider between thoughts (except for last one)
        if (index < thoughtsArray.length - 1) {
            thoughtsHtml += '<div class="rpg-thought-divider"></div>';
        }
    });

    // Create the floating thought panel with theme
    const $thoughtPanel = $(`
        <div id="rpg-thought-panel" class="rpg-thought-panel" data-theme="${theme}">
            <button class="rpg-thought-close" title="Hide thoughts">√ó</button>
            <div class="rpg-thought-circles">
                <div class="rpg-thought-circle rpg-circle-1"></div>
                <div class="rpg-thought-circle rpg-circle-2"></div>
                <div class="rpg-thought-circle rpg-circle-3"></div>
            </div>
            <div class="rpg-thought-bubble">
                ${thoughtsHtml}
            </div>
        </div>
    `);

    // Create the collapsed thought icon
    const $thoughtIcon = $(`
        <div id="rpg-thought-icon" class="rpg-thought-icon" data-theme="${theme}" title="Show thoughts">
            üí≠
        </div>
    `);

    // Apply custom theme colors if custom theme
    if (theme === 'custom') {
        const customStyles = {
            '--rpg-bg': extensionSettings.customColors.bg,
            '--rpg-accent': extensionSettings.customColors.accent,
            '--rpg-text': extensionSettings.customColors.text,
            '--rpg-highlight': extensionSettings.customColors.highlight
        };
        $thoughtPanel.css(customStyles);
        $thoughtIcon.css(customStyles);
    }

    // Force a consistent width for the bubble to ensure proper positioning
    $thoughtPanel.css('width', '350px');

    // Skip animation if this is an update (not initial creation)
    if (skipAnimation) {
        $thoughtPanel.addClass('rpg-no-animation');
    }

    // Append to body so it's not clipped by chat container
    $('body').append($thoughtPanel);
    $('body').append($thoughtIcon);    // Position the panel next to the avatar
    const panelWidth = 350;
    const panelMargin = 20;

    let top = avatarRect.top + (avatarRect.height / 2);
    let left;
    let right;
    let useRightPosition = false;
    let iconTop = avatarRect.top;
    let iconLeft;

    // Detect mobile viewport (matches CSS breakpoint)
    const isMobile = window.innerWidth <= 1000;

    if (isMobile) {
        // On mobile: position icon horizontally centered on avatar
        // The CSS transform will shift it upward by 60px
        iconTop = avatarRect.top; // Start at avatar top (CSS will move it up)
        iconLeft = avatarRect.left + (avatarRect.width / 2) - 18; // Centered horizontally (18px = half of 36px icon width)

        // Center the thought panel horizontally on mobile
        left = window.innerWidth / 2 - panelWidth / 2;
        top = avatarRect.top + avatarRect.height + 60; // Position below icon with spacing

        // No side-specific classes on mobile
        $thoughtPanel.removeClass('rpg-thought-panel-left rpg-thought-panel-right');
        $thoughtIcon.removeClass('rpg-thought-icon-left rpg-thought-icon-right');

        console.log('[RPG Companion] Mobile thought icon positioning:', {
            isMobile,
            windowWidth: window.innerWidth,
            avatarLeft: avatarRect.left,
            avatarWidth: avatarRect.width,
            iconLeft,
            iconTop
        });
    } else if (panelPosition === 'left') {
        // Main panel is on left, so thought bubble goes to RIGHT side
        // Mirror the left side positioning: bubble should be same distance from avatar
        // but on the opposite side, extending to the right
        const chatContainer = $('#chat')[0];
        const chatRect = chatContainer ? chatContainer.getBoundingClientRect() : { right: window.innerWidth };

        // Position bubble starting from chat edge, extending right
        left = chatRect.right + panelMargin; // Start at chat's right edge + margin
        useRightPosition = false; // Use left positioning so it extends right
        iconLeft = chatRect.right + 10; // Icon just at the chat edge
        $thoughtPanel.addClass('rpg-thought-panel-right');
        $thoughtIcon.addClass('rpg-thought-icon-right');

        // Position circles to flow from left (toward chat/avatar) to right (toward panel)
        $thoughtPanel.find('.rpg-thought-circles').css({
            top: 'calc(50% - 50px)',
            left: '-25px',
            bottom: 'auto',
            right: 'auto'
        });
        // Mirror the circle flow for right side (left-to-right)
        $thoughtPanel.find('.rpg-thought-circles').css('align-items', 'flex-start');
        $thoughtPanel.find('.rpg-circle-1').css({ 'align-self': 'flex-start', 'margin-right': '0', 'margin-left': '0' });
        $thoughtPanel.find('.rpg-circle-2').css({ 'align-self': 'flex-start', 'margin-right': '0', 'margin-left': '4px' });
        $thoughtPanel.find('.rpg-circle-3').css({ 'align-self': 'flex-start', 'margin-right': '0', 'margin-left': '8px' });
    } else {
        // Main panel is on right, so thought bubble goes on left (near avatar)
        left = avatarRect.left - panelWidth - panelMargin;
        iconLeft = avatarRect.left - 40;
        $thoughtPanel.addClass('rpg-thought-panel-left');
        $thoughtIcon.addClass('rpg-thought-icon-left');

        // Position circles to flow from avatar (left) to bubble (more left)
        // Circles should flow right-to-left when bubble is on left
        $thoughtPanel.find('.rpg-thought-circles').css({
            top: 'calc(50% - 50px)',
            right: '-25px',
            bottom: 'auto',
            left: 'auto'
        });
        // Keep the circle flow for left side (right-to-left) - default from CSS
        $thoughtPanel.find('.rpg-thought-circles').css('align-items', 'flex-end');
        $thoughtPanel.find('.rpg-circle-1').css({ 'align-self': 'flex-end', 'margin-left': '0', 'margin-right': '0' });
        $thoughtPanel.find('.rpg-circle-2').css({ 'align-self': 'flex-end', 'margin-left': '0', 'margin-right': '4px' });
        $thoughtPanel.find('.rpg-circle-3').css({ 'align-self': 'flex-end', 'margin-left': '0', 'margin-right': '8px' });
    }

    if (useRightPosition) {
        $thoughtPanel.css({
            top: `${top}px`,
            right: `${right}px`,
            left: 'auto' // Clear left positioning
        });
    } else {
        $thoughtPanel.css({
            top: `${top}px`,
            left: `${left}px`,
            right: 'auto' // Clear right positioning
        });
    }

    $thoughtIcon.css({
        top: `${iconTop}px`,
        left: `${iconLeft}px`,
        right: 'auto' // Clear any right positioning
    });

    // Check if always show bubble is enabled
    if (extensionSettings.alwaysShowThoughtBubble) {
        // Always show panel expanded, hide both close button and icon
        $thoughtPanel.show();
        $thoughtPanel.find('.rpg-thought-close').hide();
        $thoughtIcon.hide();
    } else {
        // Initially hide the panel and show the icon
        $thoughtPanel.hide();
        $thoughtIcon.show();

        // Close button functionality - only when always show is disabled
        $thoughtPanel.find('.rpg-thought-close').on('click', function(e) {
            e.stopPropagation();
            $thoughtPanel.fadeOut(200);
            $thoughtIcon.fadeIn(200);
        });

        // Icon click to show panel - only when always show is disabled
        $thoughtIcon.on('click', function(e) {
            e.stopPropagation();
            $thoughtIcon.fadeOut(200);
            $thoughtPanel.fadeIn(200);
        });
    }

    // console.log('[RPG Companion] Thought panel created at:', { top, left });

    // Add event handlers for editable thoughts in the bubble
    $thoughtPanel.find('.rpg-editable').on('blur', function() {
        const character = $(this).data('character');
        const field = $(this).data('field');
        const value = $(this).text().trim();
        // console.log('[RPG Companion] üí≠ Thought bubble blur event - character:', character, 'field:', field, 'value:', value);
        updateCharacterField(character, field, value);
    });

    // Add event handler for regenerate buttons in thought bubbles
    $thoughtPanel.find('.rpg-thought-regen-btn').on('click', async function(e) {
        e.stopPropagation();
        const characterName = $(this).data('character');
        await regenerateIndividualThought(characterName);
    });

    // RAF throttling for smooth position updates
    let positionUpdateRaf = null;

    // Update position on scroll with RAF throttling
    const updatePanelPosition = () => {
        if (!$message.is(':visible')) {
            $thoughtPanel.hide();
            $thoughtIcon.hide();
            return;
        }

        // Cancel any pending RAF
        if (positionUpdateRaf) {
            cancelAnimationFrame(positionUpdateRaf);
        }

        // Schedule update on next frame
        positionUpdateRaf = requestAnimationFrame(() => {
            const newAvatarRect = $avatar[0].getBoundingClientRect();
            const newTop = newAvatarRect.top + (newAvatarRect.height / 2);
            const newIconTop = newAvatarRect.top;
            let newLeft, newIconLeft;

            if (panelPosition === 'left') {
                // Position at chat's right edge, extending right
                const chatContainer = $('#chat')[0];
                const chatRect = chatContainer ? chatContainer.getBoundingClientRect() : { right: window.innerWidth };
                newLeft = chatRect.right + panelMargin;
                newIconLeft = chatRect.right + 10;

                $thoughtPanel.css({
                    top: `${newTop}px`,
                    left: `${newLeft}px`,
                    right: 'auto'
                });
            } else {
                // Left position relative to avatar
                newLeft = newAvatarRect.left - panelWidth - panelMargin;
                newIconLeft = newAvatarRect.left - 40;

                $thoughtPanel.css({
                    top: `${newTop}px`,
                    left: `${newLeft}px`,
                    right: 'auto'
                });
            }

            $thoughtIcon.css({
                top: `${newIconTop}px`,
                left: `${newIconLeft}px`,
                right: 'auto'
            });

            if ($thoughtPanel.is(':visible')) {
                $thoughtPanel.show();
            }
            if ($thoughtIcon.is(':visible')) {
                $thoughtIcon.show();
            }

            positionUpdateRaf = null;
        });
    };

    // Update position on scroll and resize
    $('#chat').on('scroll.thoughtPanel', updatePanelPosition);
    $(window).on('resize.thoughtPanel', updatePanelPosition);

    // Remove panel when clicking outside - only if always show is disabled
    if (!extensionSettings.alwaysShowThoughtBubble) {
        $(document).on('click.thoughtPanel', function(e) {
            if (!$(e.target).closest('#rpg-thought-panel, #rpg-thought-icon').length) {
                // Hide the panel and show the icon instead of removing
                $thoughtPanel.fadeOut(200);
                $thoughtIcon.fadeIn(200);
            }
        });
    }
}

/**
 * Regenerates a single character's thought from the thought bubble widget
 * @param {string} characterName - Name of the character whose thought to regenerate
 */
async function regenerateIndividualThought(characterName) {
    try {
        toastr.info(`Regenerating thought for ${characterName}...`, 'RPG Companion');

        // Import regeneration functions
        const { buildFieldRegenerationPrompt, callLLMForGeneration, parseFieldRegenerationResponse } = await import('../ui/characterRegeneration.js');

        // Get current character data from Present Characters
        const lines = committedTrackerData.characterThoughts?.split('\n') || [];
        const currentData = {};
        let inCharacter = false;
        let currentCharName = null;

        for (const line of lines) {
            const trimmed = line.trim();

            // Check for character name line
            if (trimmed && !trimmed.includes(':') && !trimmed.includes('---')) {
                currentCharName = trimmed;
                inCharacter = (currentCharName === characterName);
                continue;
            }

            // If we're in the target character, parse their data
            if (inCharacter && trimmed.includes(':')) {
                const colonIndex = trimmed.indexOf(':');
                const fieldName = trimmed.substring(0, colonIndex).trim();
                const fieldValue = trimmed.substring(colonIndex + 1).trim();
                currentData[fieldName] = fieldValue;
            }
        }

        // Get field configuration
        const config = extensionSettings.trackerConfig?.presentCharacters;
        const thoughtsConfig = config?.thoughts;
        const fieldConfig = {
            name: thoughtsConfig?.name || 'Thoughts',
            description: thoughtsConfig?.description || 'Internal monologue (in first person POV, up to three sentences long)'
        };

        // Build prompt
        const prompt = await buildFieldRegenerationPrompt(characterName, fieldConfig.name, currentData, '', fieldConfig);

        // Get field regeneration settings for thoughts
        const fieldSettings = extensionSettings.characterFieldRegenerationSettings || {};
        const maxTokens = fieldSettings.thoughtsMaxTokens || 150;
        const stopSequences = fieldSettings.thoughtsStopSequences || ['\n\n', '###', 'Here is', 'I hope'];

        // Call LLM
        const response = await callLLMForGeneration(prompt, {
            maxTokens: maxTokens,
            stopSequences: stopSequences
        });

        // Parse response
        const newThought = parseFieldRegenerationResponse(response);

        // Update the character's thought
        updateCharacterField(characterName, fieldConfig.name, newThought);

        toastr.success(`Thought regenerated for ${characterName}`, 'RPG Companion');
    } catch (error) {
        console.error('[RPG Companion] Individual thought regeneration failed:', error);
        toastr.error(`Failed to regenerate thought: ${error.message}`, 'RPG Companion');
    }
}
